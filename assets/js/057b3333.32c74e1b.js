(self.webpackChunkmunus_webiste=self.webpackChunkmunus_webiste||[]).push([[932],{3905:function(e,t,l){"use strict";l.d(t,{Zo:function(){return c},kt:function(){return k}});var n=l(7294),a=l.n(n);function r(e,t,l){return t in e?Object.defineProperty(e,t,{value:l,enumerable:!0,configurable:!0,writable:!0}):e[t]=l,e}function i(e,t){var l=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),l.push.apply(l,n)}return l}function o(e){for(var t=1;t<arguments.length;t++){var l=null!=arguments[t]?arguments[t]:{};t%2?i(Object(l),!0).forEach((function(t){r(e,t,l[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(l)):i(Object(l)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(l,t))}))}return e}function u(e,t){if(null==e)return{};var l,n,a=function(e,t){if(null==e)return{};var l,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)l=r[n],t.indexOf(l)>=0||(a[l]=e[l]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)l=r[n],t.indexOf(l)>=0||Object.prototype.propertyIsEnumerable.call(e,l)&&(a[l]=e[l])}return a}var s=a().createContext({}),p=function(e){var t=a().useContext(s),l=t;return e&&(l="function"==typeof e?e(t):o(o({},t),e)),l},c=function(e){var t=p(e.components);return a().createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a().createElement(a().Fragment,{},t)}},d=a().forwardRef((function(e,t){var l=e.components,n=e.mdxType,r=e.originalType,i=e.parentName,s=u(e,["components","mdxType","originalType","parentName"]),c=p(l),d=n,k=c["".concat(i,".").concat(d)]||c[d]||m[d]||r;return l?a().createElement(k,o(o({ref:t},s),{},{components:l})):a().createElement(k,o({ref:t},s))}));function k(e,t){var l=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=l.length,i=new Array(r);i[0]=d;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:n,i[1]=o;for(var s=2;s<r;s++)i[s]=l[s];return a().createElement.apply(null,i)}return a().createElement.apply(null,l)}d.displayName="MDXCreateElement"},5173:function(e,t,l){"use strict";l.r(t),l.d(t,{frontMatter:function(){return o},metadata:function(){return u},toc:function(){return s},default:function(){return c}});var n=l(2122),a=l(9756),r=(l(7294),l(3905)),i=["components"],o={id:"data-structures",title:"Data structures",sidebar_label:"Data structures"},u={unversionedId:"data-structures",id:"data-structures",isDocsHomePage:!1,title:"Data structures",description:"Functional programming is all about values. Value is the basic and most important type of this library.",source:"@site/docs/data-structures.md",sourceDirName:".",slug:"/data-structures",permalink:"/docs/data-structures",version:"current",sidebar_label:"Data structures",frontMatter:{id:"data-structures",title:"Data structures",sidebar_label:"Data structures"},sidebar:"docs",previous:{title:"Generic types",permalink:"/docs/generic-types"},next:{title:"Tuple",permalink:"/docs/tuple"}},s=[{value:"Value",id:"value",children:[]},{value:"Traversable",id:"traversable",children:[]},{value:"Collectors",id:"collectors",children:[]}],p={toc:s};function c(e){var t=e.components,l=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,n.Z)({},p,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Functional programming is all about values. ",(0,r.kt)("inlineCode",{parentName:"p"},"Value")," is the basic and most important type of this library.\nWhat you need to know about ",(0,r.kt)("inlineCode",{parentName:"p"},"Value"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"it is immutable by default"),(0,r.kt)("li",{parentName:"ul"},"it is generic wrapper"),(0,r.kt)("li",{parentName:"ul"},"it can be empty"),(0,r.kt)("li",{parentName:"ul"},"it can be safely compared with other value")),(0,r.kt)("p",null,"Each value class extends base ",(0,r.kt)("inlineCode",{parentName:"p"},"Value")," which contains generic ",(0,r.kt)("inlineCode",{parentName:"p"},"template")," annotation.\nThis allow us to use values as wrapper for our custom domain types.\nRead ",(0,r.kt)("a",{parentName:"p",href:"/docs/generic-types"},"Generic types")," tab to learn more about how Munus uses generic types."),(0,r.kt)("h2",{id:"value"},"Value"),(0,r.kt)("p",null,"Basic operations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"get()")," - returns the underlying value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getOrElse($other)")," - returns the underlying value if present, otherwise return $other"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getOrElseThrow(Throwable $throwable)")," -  returns the underlying value if present, otherwise throws $throwable"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getOrElseTry(callable $supplier)")," - returns the underlying value if present, otherwise returns the result of $supplier"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getOrNull()")," - returns the underlying value if present, otherwise returns null"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"map(callable $mapper)")," - maps the underlying value to a different type")),(0,r.kt)("p",null,"Equality checks:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"equals($object): bool")," - checks, if types are equals, for collections it checks if all values are equal and on the same order ")),(0,r.kt)("p",null,"Iterable extensions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"contains($element): bool")," - checks, if the given element is contained"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"exists(callable $predicate): bool")," - checks, if an element exists such that the predicate holds "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"forEach(callable $consumer)")," - performs an action on each element"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"forAll(callable $predicate)")," - checks, if the given predicate is true for all elements"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"iterator()")," - returns appropriate ",(0,r.kt)("inlineCode",{parentName:"li"},"Iterator")," which allows to iterate through all elements ")),(0,r.kt)("p",null,"Side-effects:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"peek(callable $action)")," - performs given action on first element")),(0,r.kt)("p",null,"Tests:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"isEmpty(): bool")," - checks, if the underlying value is absent"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"isSingleValued(): bool"),"- states whether this is a single-valued type")),(0,r.kt)("p",null,"Type conversion:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"collect(Collector $collector)")," - collects the underlying value(s) (if present) using the provided $collector, available collectors are described below"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"toOption()")," - converts value to an ",(0,r.kt)("inlineCode",{parentName:"li"},"Option")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"toStream()")," - converts value to a ",(0,r.kt)("inlineCode",{parentName:"li"},"Stream")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"toArray()")," - converts value to native PHP array ",(0,r.kt)("inlineCode",{parentName:"li"},"[]"))),(0,r.kt)("h2",{id:"traversable"},"Traversable"),(0,r.kt)("p",null,"An interface for inherently recursive, multi-valued data structures. The order of elements is determined by\nIterator, which may vary each time it is called."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Traversable")," extends ",(0,r.kt)("inlineCode",{parentName:"p"},"Value"),", so each above methods are also available for each ",(0,r.kt)("inlineCode",{parentName:"p"},"Traversable"),".  "),(0,r.kt)("p",null,"Basic operations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"length()")," - computes the number of elements of this traversable"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"head()")," - returns the first element"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tail()")," - drops the first element and return new Traversable containing all elements except the first")),(0,r.kt)("p",null,"Numeric operations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"average()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"min()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"product()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sum()"))),(0,r.kt)("p",null,"Reduction:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"count(callable $predicate):int")," - counts the elements which satisfy the given predicate"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fold($zero, callable $combine)")," - folds this elements starting with $zero and successively calling $combine"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"reduce(callable $operation)")," - accumulates the elements by successively calling the given $operation")),(0,r.kt)("p",null,"Selection:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dropWhile(callable $predicate)")," - drops elements while the predicate holds for the current element"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dropUntil(callable $predicate)")," - drops elements until the predicate holds for the current element"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filter(callable $predicate)")," - returns a new traversable consisting of all elements which satisfy the given predicate"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filterNot(callable $predicate)")," - returns a new traversable consisting of all elements which do not satisfy the given predicate")),(0,r.kt)("h2",{id:"collectors"},"Collectors"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Collectors::toList()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Collectors::toSet()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Collectors::toMap(callable $keyProvider)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Collectors::summing()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Collectors::joining(string $glue)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Collectors::counting()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Collectors::averaging()"))))}c.isMDXComponent=!0}}]);